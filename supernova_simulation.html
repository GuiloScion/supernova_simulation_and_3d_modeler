<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Supernova Physics Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
    top: auto;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
        }
        
        #info {
            position: absolute;
            bottom: 20px;
    top: auto;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 150px;
            margin-right: 10px;
        }
        
        button {
            background: #1a4f8a;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
        }
        
        button:hover {
            background: #2a5f9a;
        }
        
        .phase {
            font-weight: bold;
            color: #ff6b6b;
        }
        
        .value {
            color: #4ecdc4;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>Supernova Controls</h3>
            <div class="control-group">
                <label>Stellar Mass (Solar Masses)</label>
                <input type="range" id="stellarMass" min="8" max="40" value="20" step="1">
                <span id="massValue" class="value">20</span>
            </div>
            <div class="control-group">
                <label>Metallicity</label>
                <input type="range" id="metallicity" min="0.001" max="0.02" value="0.01" step="0.001">
                <span id="metallicityValue" class="value">0.010</span>
            </div>
            <div class="control-group">
                <label>Time Scale (Speed)</label>
                <input type="range" id="timeScale" min="0.1" max="5.0" value="1.0" step="0.1">
                <span id="timeScaleValue" class="value">1.0x</span>
            </div>
            <div class="control-group">
                <button onclick="startSupernova()">Initiate Core Collapse</button>
                <button onclick="resetSimulation()">Reset</button>
                <button onclick="togglePause()">Pause/Play</button>
            </div>
        </div>
        
        <div id="info">
            <h3>Supernova Physics</h3>
            <div>Phase: <span id="phase" class="phase">Pre-collapse</span></div>
            <div>Time: <span id="timeDisplay" class="value">0.00 s</span></div>
            <div>Core Temperature: <span id="coreTemp" class="value">5.0×10⁸ K</span></div>
            <div>Core Density: <span id="coreDensity" class="value">3.0×10⁶ g/cm³</span></div>
            <div>Shock Velocity: <span id="shockVel" class="value">0 km/s</span></div>
            <div>Energy Released: <span id="energyReleased" class="value">0 erg</span></div>
            <div>Neutrino Flux: <span id="neutrinoFlux" class="value">0 /cm²/s</span></div>
            <div>Magnetic Field: <span id="magneticField" class="value">0 G</span></div>
            <div>Shock Radius: <span id="shockRadius" class="value">0 km</span></div>
            <div>Elements Created:</div>
            <div id="elements" style="font-size: 10px; margin-top: 5px; color: #aaa;"></div>
        </div>
    </div>

    <script>
        // Physics constants
        const SOLAR_MASS = 1.989e33;
        const SOLAR_RADIUS = 6.96e8;
        const G = 6.674e-11;
        const C = 299792458;
        const BOLTZMANN = 1.381e-23;
        
        // Global variables
        let scene, camera, renderer, clock;
        let starCore, shockWave, ejectaMaterial, neutronStar;
        let particles = [];
        let supernovaActive = false;
        let isPaused = false;
        let simulationTime = 0;
        let phase = "pre-collapse";
        let stellarMass = 20;
        let metallicity = 0.01;
        let timeScale = 1.0;
        let coreCollapsed = false;
        let shockRadius = 0;
        let maxShockRadius = 0;
        let neutrinoFlux = 0;
        let magneticField = 0;
        let starLight;
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011);
            document.getElementById('container').appendChild(renderer.domElement);
            
            camera.position.set(0, 0, 1000);
            camera.lookAt(0, 0, 0);
            
            clock = new THREE.Clock();
            
            createStarfield();
            createStar();
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.1);
            scene.add(ambientLight);
            
            starLight = new THREE.PointLight(0xffaa00, 2, 1000);
            starLight.position.set(0, 0, 0);
            scene.add(starLight);
        }
        
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 4000;
                positions[i + 1] = (Math.random() - 0.5) * 4000;
                positions[i + 2] = (Math.random() - 0.5) * 4000;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        function createStar() {
            const starGeometry = new THREE.SphereGeometry(50, 64, 64);
            const starMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa44,
                transparent: true,
                opacity: 0.9
            });
            
            starCore = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starCore);
            
            // Add corona effect
            const coronaGeometry = new THREE.SphereGeometry(60, 32, 32);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            starCore.add(corona);
        }
        
        function createShockWave() {
            if (shockWave) {
                scene.remove(shockWave);
            }
            
            const shockGeometry = new THREE.SphereGeometry(1, 32, 32);
            const shockMaterial = new THREE.MeshBasicMaterial({
                color: 0xff3300,
                transparent: true,
                opacity: 0.6,
                side: THREE.BackSide
            });
            
            shockWave = new THREE.Mesh(shockGeometry, shockMaterial);
            scene.add(shockWave);
        }
        
        function createEjectaParticles() {
            if (ejectaMaterial) {
                scene.remove(ejectaMaterial);
            }
            
            const particleCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Random position on sphere surface
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 50 + Math.random() * 10;
                
                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
                
                // Velocity vector
                const speed = (500 + Math.random() * 1500) * 0.1;
                velocities.push({
                    x: (positions[i3] / r) * speed,
                    y: (positions[i3 + 1] / r) * speed,
                    z: (positions[i3 + 2] / r) * speed
                });
                
                // Element-based colors
                const elementType = Math.random();
                if (elementType < 0.3) { // Iron peak
                    colors[i3] = 1.0; colors[i3 + 1] = 0.4; colors[i3 + 2] = 0.1;
                } else if (elementType < 0.6) { // Light elements
                    colors[i3] = 0.1; colors[i3 + 1] = 0.6; colors[i3 + 2] = 1.0;
                } else { // Heavy elements
                    colors[i3] = 0.8; colors[i3 + 1] = 0.2; colors[i3 + 2] = 0.8;
                }
                
                sizes[i] = 1 + Math.random() * 2;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Store velocities separately for animation
            geometry.userData = { velocities: velocities, initialPositions: positions.slice() };
            
            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            ejectaMaterial = new THREE.Points(geometry, material);
            scene.add(ejectaMaterial);
        }
        
        function createNeutronStar() {
            if (neutronStar) {
                scene.remove(neutronStar);
            }
            
            const nsGeometry = new THREE.SphereGeometry(2, 32, 32);
            const nsMaterial = new THREE.MeshBasicMaterial({
                color: 0xccddff,
                transparent: true,
                opacity: 1.0
            });
            
            neutronStar = new THREE.Mesh(nsGeometry, nsMaterial);
            neutronStar.visible = false;
            scene.add(neutronStar);
        }
        
        function createNeutrinoFlash() {
            const flashGeometry = new THREE.RingGeometry(100, 150, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.rotation.x = Math.random() * Math.PI;
            flash.rotation.y = Math.random() * Math.PI;
            scene.add(flash);
            
            // Animate flash
            let flashOpacity = 0.3;
            let flashScale = 1.0;
            const animateFlash = () => {
                flashScale += 0.05;
                flashOpacity -= 0.01;
                
                if (flashOpacity <= 0) {
                    scene.remove(flash);
                    return;
                }
                
                flash.scale.setScalar(flashScale);
                flash.material.opacity = flashOpacity;
                requestAnimationFrame(animateFlash);
            };
            animateFlash();
        }
        
        // Physics calculations
        function calculateCoreCollapse(t) {
            const collapseTime = 0.1;
            const progress = Math.min(t / collapseTime, 1.0);
            
            if (progress < 1.0) {
                phase = "Core Collapse";
                const density = 3e6 * Math.pow(10, progress * 8);
                const temperature = 5e8 * Math.pow(10, progress * 2);
                return { density, temperature, progress };
            } else {
                if (!coreCollapsed) {
                    coreCollapsed = true;
                    createShockWave();
                    createEjectaParticles();
                    createNeutronStar();
                }
                return { density: 3e14, temperature: 5e10, progress: 1.0 };
            }
        }
        
        function calculateShockPropagation(t) {
            if (!coreCollapsed) return { radius: 0, velocity: 0 };
            
            const shockTime = t - 0.1;
            if (shockTime < 0) return { radius: 0, velocity: 0 };
            
            if (shockTime < 1.0) {
                phase = "Shock Breakout";
                const velocity = 10000 + shockTime * 5000;
                const radius = 50 + velocity * shockTime * 0.01;
                return { radius, velocity };
            } else if (shockTime < 10.0) {
                phase = "Expansion";
                const velocity = 15000 - (shockTime - 1) * 1000;
                const radius = 150 + velocity * (shockTime - 1) * 0.01;
                return { radius, velocity };
            } else {
                phase = "Supernova Remnant";
                const velocity = Math.max(1000, 5000 - (shockTime - 10) * 100);
                const radius = 300 + velocity * (shockTime - 10) * 0.01;
                return { radius, velocity };
            }
        }
        
        function calculateNucleosynthesis(t) {
            const elements = {};
            if (t < 0.1) return elements;
            
            const progress = Math.min((t - 0.1) / 2.0, 1.0);
            
            elements['⁵⁶Fe'] = Math.floor(progress * 60);
            elements['⁵⁶Ni'] = Math.floor(progress * 40);
            elements['²⁸Si'] = Math.floor(progress * 80);
            elements['³²S'] = Math.floor(progress * 50);
            
            if (progress > 0.5) {
                elements['⁹⁰Sr'] = Math.floor((progress - 0.5) * 40);
                elements['¹³⁷Cs'] = Math.floor((progress - 0.5) * 25);
            }
            
            return elements;
        }
        
        function updatePhysics(deltaTime) {
            if (!supernovaActive || isPaused) return;
            
            simulationTime += deltaTime * timeScale;
            
            const coreData = calculateCoreCollapse(simulationTime);
            const shockData = calculateShockPropagation(simulationTime);
            shockRadius = shockData.radius;
            
            updateVisuals(coreData, shockData, simulationTime);
            updateInfoDisplay(coreData, shockData, simulationTime);
        }
        
        function updateVisuals(coreData, shockData, time) {
            // Update star core
            if (starCore) {
                if (coreData.progress > 0) {
                    const scale = 1.0 - coreData.progress * 0.95;
                    starCore.scale.setScalar(scale);
                    
                    // Color change during collapse
                    const intensity = 1.0 + coreData.progress * 3.0;
                    starCore.material.color.setRGB(intensity, intensity * 0.6, intensity * 0.2);
                }
                
                if (coreCollapsed && time > 0.5) {
                    starCore.visible = false;
                    if (neutronStar) neutronStar.visible = true;
                }
            }
            
            // Update shock wave
            if (shockWave && shockData.radius > 0) {
                shockWave.visible = true;
                shockWave.scale.setScalar(shockData.radius / 50);
                
                const intensity = Math.max(0.1, 1.0 - time / 20.0);
                shockWave.material.opacity = intensity * 0.6;
            }
            
            // Update ejecta particles
            if (ejectaMaterial && time > 0.1) {
                const positions = ejectaMaterial.geometry.attributes.position.array;
                const velocities = ejectaMaterial.geometry.userData.velocities;
                const initialPos = ejectaMaterial.geometry.userData.initialPositions;
                
                const ejectaTime = time - 0.1;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const idx = i / 3;
                    if (velocities[idx]) {
                        positions[i] = initialPos[i] + velocities[idx].x * ejectaTime;
                        positions[i + 1] = initialPos[i + 1] + velocities[idx].y * ejectaTime;
                        positions[i + 2] = initialPos[i + 2] + velocities[idx].z * ejectaTime;
                    }
                }
                
                ejectaMaterial.geometry.attributes.position.needsUpdate = true;
                
                // Fade out over time
                if (time > 15.0) {
                    const fadeProgress = (time - 15.0) / 10.0;
                    ejectaMaterial.material.opacity = Math.max(0, 0.8 - fadeProgress);
                }
            }
            
            // Update neutron star
            if (neutronStar && neutronStar.visible) {
                // Pulsing effect
                const pulse = Math.sin(time * 30) * 0.3 + 0.7;
                neutronStar.material.opacity = pulse;
                neutronStar.rotation.y += 0.1;
            }
        }
        
        function updateInfoDisplay(coreData, shockData, time) {
            document.getElementById('phase').textContent = phase;
            document.getElementById('timeDisplay').textContent = time.toFixed(2) + ' s';
            document.getElementById('coreTemp').textContent = (coreData.temperature / 1e9).toFixed(1) + '×10⁹ K';
            document.getElementById('coreDensity').textContent = (coreData.density / 1e6).toFixed(1) + '×10⁶ g/cm³';
            document.getElementById('shockVel').textContent = Math.floor(shockData.velocity).toLocaleString() + ' km/s';
            
            const energy = Math.pow(10, 44) * Math.min(time / 10.0, 1.0);
            document.getElementById('energyReleased').textContent = energy.toExponential(2) + ' erg';
            
            document.getElementById('neutrinoFlux').textContent = neutrinoFlux.toExponential(1) + ' /cm²/s';
            document.getElementById('magneticField').textContent = magneticField.toExponential(1) + ' G';
            document.getElementById('shockRadius').textContent = Math.floor(shockRadius * 1000).toLocaleString() + ' km';
            
            const elements = calculateNucleosynthesis(time);
            const elementDisplay = Object.entries(elements)
                .map(([el, amount]) => `${el}: ${amount}%`)
                .join(', ');
            document.getElementById('elements').textContent = elementDisplay;
        }
        
        // Control functions
        function startSupernova() {
            supernovaActive = true;
            simulationTime = 0;
            coreCollapsed = false;
            shockRadius = 0;
            phase = "Pre-collapse";
            neutrinoFlux = 0;
            magneticField = 0;
            
            if (starCore) {
                starCore.visible = true;
                starCore.scale.setScalar(1.0);
                starCore.material.color.setRGB(1.0, 0.6, 0.2);
            }
            if (neutronStar) neutronStar.visible = false;
            if (shockWave) {
                shockWave.visible = false;
                scene.remove(shockWave);
            }
            if (ejectaMaterial) {
                scene.remove(ejectaMaterial);
            }
        }
        
        function resetSimulation() {
            supernovaActive = false;
            isPaused = false;
            simulationTime = 0;
            coreCollapsed = false;
            phase = "Pre-collapse";
            
            // Clear scene and rebuild
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            initScene();
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        // Advanced physics background calculations
        function runAdvancedPhysics() {
            if (!supernovaActive) return;
            
            // Neutrino emission
            if (simulationTime > 0.05 && simulationTime < 10.0) {
                neutrinoFlux = Math.pow(10, 58) * Math.exp(-simulationTime / 2.0);
                
                if (Math.random() < 0.1) {
                    createNeutrinoFlash();
                }
            } else {
                neutrinoFlux = 0;
            }
            
            // Magnetic field evolution
            if (coreCollapsed) {
                magneticField = Math.pow(10, 15) * Math.exp(-simulationTime / 5.0);
            }
        }
        
        // Event listeners
        document.getElementById('stellarMass').addEventListener('input', function(e) {
            stellarMass = parseFloat(e.target.value);
            document.getElementById('massValue').textContent = stellarMass;
        });
        
        document.getElementById('metallicity').addEventListener('input', function(e) {
            metallicity = parseFloat(e.target.value);
            document.getElementById('metallicityValue').textContent = metallicity.toFixed(3);
        });
        
        document.getElementById('timeScale').addEventListener('input', function(e) {
            timeScale = parseFloat(e.target.value);
            document.getElementById('timeScaleValue').textContent = timeScale.toFixed(1) + 'x';
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            updatePhysics(deltaTime);
            
            // Cinematic camera movement
            if (supernovaActive && simulationTime > 0.1) {
                const radius = 600 + Math.sin(simulationTime * 0.2) * 200;
                camera.position.x = Math.sin(simulationTime * 0.1) * radius;
                camera.position.z = Math.cos(simulationTime * 0.1) * radius;
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // Window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Background physics timer
        setInterval(runAdvancedPhysics, 100);
        
        // Initialize
        initScene();
        animate();
        
        console.log("Advanced Supernova Simulation Ready");
        console.log("Click 'Initiate Core Collapse' to begin simulation");
    </script>
</body>
</html>